<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<style type="text/css">
			ul,ol { margin: 12px; }
			li { margin: 10px; }
		</style>
		<title>README</title>
	</head>
	<body>
		<h3>加载过程</h3>
		<ul>
			<li>
				首先加载框架<strong>DrawFrame</strong>(该类继承自<strong>JFrame</strong>)在构造函数内部发生如下事件:
				<ol>
					<li>创建<strong>DrawComponent</strong>(该类继承自<strong>JComponent</strong>)和<strong>JPanel</strong>对象,<strong>JPanel</strong>对象用作<strong>JButton</strong>的容器;</li>
					<li>使用<strong>ShapeFactory</strong>类创建<strong>Shapes</strong>包中的<strong>MyShape</strong>子类对象——类名由<strong>ButtonFactory</strong>的类方法获取——并根据<i>getButton()</i>的返回值创建相应按钮,同时创建其余按钮;</li>
					<li>将容器<strong>JPanel</strong>对象和绘画区域<strong>DrawComponent</strong>对象添加到框架中.</li>
				</ol>
			</li>
			<li>
				创建<strong>DrawComponent</strong>对象时其构造函数内部的情况:
				<ol>
					<li>根据文件<i>ShapeList</i>的有无选择相应的操作.(初次运行画板时该文件不存在也没有任何<strong>MyShapes</strong>对象存在,读写都将引发异常并被捕获);</li>
					<li>让<strong>DrawComponent</strong>监听鼠标事件.</li>
				</ol>
			</li>
		</ul>
		<h3>绘画过程:</h3>
		<ul>
			<li>单击相应按钮,触发<strong>ActionEvent</strong>事件,调用<strong>DrawFrame</strong>的<i>actionEvent()</i>函数;调用<strong>DrawComponent</strong>的<i>setPainter()</i>方法,通过<strong>PainterFactory</strong>创建相应的<strong>MyPainter</strong>对象,以此设置<strong>DrawComponent</strong>的私有<strong>MyPainter</strong>对象painter.
			</li>
			<li>在绘画区域按下鼠标(未拖动),触发<strong>MousePressed</strong>事件,调用<strong>DrawComponent</strong>的<i>mousePressed()</i>函数,初次绘画时<i>currentShape</i>为<i>null</i>,进入绘画模式,从而调用<i>painter</i>对象的<i>mousePressed()</i>方法,发生如下事件:
				<ol>
					<li>按击点被添加到超类<strong>MyPainter</strong>的<strong>Vector</strong>对象<i>points</i>中,接着创建相应的<strong>MyShape</strong>对象,并设置<strong>DrawComponent</strong>的私有<strong>MyShape</strong>对象<i>drawingShape</i>.</li>
					<li>将<i>drawingShape</i>添加到<strong>DrawComponent</strong>的<strong>ArrayList</strong>对象<i>shapes</i>中——<i>shapes</i>用于储存绘画操作产生的<strong>MyShape</strong>对象.</li>
				</ol>
			</li>
			<li>按下鼠标后开始拖动,触发<strong>MouseDragged</strong>事件,调用<strong>DrawComponent</strong>的<i>mouseDragged()</i>函数,<i>currentShape</i>为<i>null</i>,从而调用<i>painter</i>对象的<i>mouseDragged()</i>方法,发生如下事件:
				<ol>
					<li>调用<strong>Dragger</strong>的<i>drag()</i>方法,根据拖动轨迹上的点修改<i>drawingShape</i>;</li>
					<li>将修改后的<i>drawingShape</i>返回,实现更新.</li>
				</ol>
			</li>
			<li>放开鼠标,触发<strong>MouseReleased</strong>事件,调用<strong>DrawComponent</strong>的<i>mouseReleased()</i>函数,转向<i>painter</i>对象的<i>mouseReleased()</i>方法,该方法将<strong>MyPainter</strong>中的<i>points</i>清空,以备后面的绘画需要.</li>
		</ul>
		<h3>拖动过程:</h3>
		<ul>
			<li>鼠标在图形内部点击,触发相应的鼠标事件,调用<strong>DrawComponent</strong>的<i>mousePressed()</i>函数.<i>currentShape</i>不为<i>null</i>,并通过其<i>getClassName()</i>获取相应类名作为参数来调用<i>setPainter()</i>,从而获得操作图形的<strong>MyPainter</strong>对象;</li>
			<li>将按击点添加到<i>movePoint</i>中,作为拖动时的参考点.</li>
			<li>鼠标开始拖动,触发<storng>MouseDragged</storng>事件,调用<strong>DrawComponent</strong>的<i>mouseDragged()</i>函数:</li>
			<ol>
				<li>将拖动轨迹上的点添加到<i>movePoint</i>中;</li>
				<li>调用<i>currentShape</i>的<i>move()</i>方法,执行拖动操作.(<i>currentShape</i>引用的<strong>MyShape</strong>对象会通过<i>init()</i>重置图形特殊点,实现当前对象<i>currentShape</i>的重置)</li>
				<li>repaint()</i>重绘<i>currentShape</i></li>
			</ol>
		</ul>
	</body>
</html>